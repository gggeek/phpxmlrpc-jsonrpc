<?php

namespace PhpXmlRpc\JsonRpc;

use PhpXmlRpc\Client as BaseClient;
use PhpXmlRpc\Exception\ValueErrorException;
use PhpXmlRpc\Helper\Interop;
use PhpXmlRpc\JsonRpc\Helper\Parser;
use PhpXmlRpc\JsonRpc\Traits\JsonRpcVersionAware;
use PhpXmlRpc\PhpXmlRpc;

/**
 * @todo the JSON proposed RFC states that when making json calls, we should specify an 'accept: application/json'
 *       http header. Currently, we either do not output an 'accept' header or specify 'any' (in curl mode)
 */
class Client extends BaseClient
{
    use JsonRpcVersionAware;

    protected static $requestClass = '\\PhpXmlRpc\\JsonRpc\\Request';
    protected static $responseClass = '\\PhpXmlRpc\\JsonRpc\\Response';

    const OPT_JSONRPC_VERSION = 'jsonrpc_version';

    protected static $extra_options = array(
        self::OPT_JSONRPC_VERSION,
    );

    // by default, no multicall exists for JSON-RPC, so do not try it
    public $no_multicall = true;

    // default return type of calls to json-rpc servers: jsonrpcvals
    public $return_type = Parser::RETURN_JSONRPCVALS;

    // according to https://tools.ietf.org/html/rfc8259#section-8.1, UTF8 is the rule
    public $request_charset_encoding = 'UTF-8';

    public function __construct($path, $server='', $port='', $method='')
    {
        parent::__construct($path, $server, $port, $method);

        // @todo we need to override the list of std supported encodings, since according to ECMA-262, the standard
        //       charset is UTF-16...
        //$this->accepted_charset_encodings = array('UTF-16', 'UTF-8', 'ISO-8859-1', 'US-ASCII');

        $this->user_agent =  PhpJsonRpc::$jsonrpcName . ' ' . PhpJsonRpc::$jsonrpcVersion . ' (' . PhpXmlRpc::$xmlrpcName . ' ' . PhpXmlRpc::$xmlrpcVersion . ')';
    }

    public function setOption($name, $value)
    {
        if (in_array($name, static::$options) || in_array($name, static::$extra_options)) {
            $this->$name = $value;
            return $this;
        }

        throw new ValueErrorException("Unsupported option '$name'");
    }

    /**
     * @param string $name see all the OPT_ constants
     * @return mixed
     * @throws ValueErrorException on unsupported option
     */
    public function getOption($name)
    {
        if (in_array($name, static::$options) || in_array($name, static::$extra_options)) {
            return $this->$name;
        }

        throw new ValueErrorException("Unsupported option '$name'");
    }

    /**
     * @param \PhpXmlRpc\JsonRpc\Request|\PhpXmlRpc\JsonRpc\Request[]|string $req
     * @param int $timeout deprecated
     * @param string $method deprecated
     * @return \PhpXmlRpc\JsonRpc\Response|true|\PhpXmlRpc\JsonRpc\Response[] true for notification calls, if the server
     *         returns an empty http response body
     */
    public function send($req, $timeout = 0, $method = '')
    {
        if ($this->jsonrpc_version != '') {
            if (is_array($req)) {
                foreach ($req as $i => $r) {
                    if (!is_string($r)) {
                        $req[$i]->setJsonRpcVersion($this->jsonrpc_version);
                    }
                }
            } elseif (!is_string($req)) {
                $req->setJsonRpcVersion($this->jsonrpc_version);
            }
        }

        /** @var Response $resp */
        $resp = parent::send($req, $timeout, $method);

        // For all cases where the response is not sent from the server, but generated by the client/request, we have to
        // inject the req. Id and jsonrpc version
        if (is_array($req)) {
            foreach ($req as $i => $r) {
                /// @todo test: does this work when notifications are mixed with calls?
                if (!is_string($r)) {
                    if (!is_bool($resp[$i]) && !$r->parsedResponseIsFromServer()) {
                        if ($r->id() !== null) {
                            $resp[$i] = call_user_func_array(array(static::$responseClass, 'withId'),
                                array($resp[$i], $r->id()));
                        }
                        if ($this->jsonrpc_version !== null) {
                            $resp[$i]->setJsonRpcVersion($this->jsonrpc_version);
                        }
                        $this->fixErrorCodeIfNeeded($resp[$i]);
                    }
                    // fix the following corner case: the client sends twice the same request object, and on the 2nd try
                    // it returns an error resp. without going through $req->parseResponse(). In that case,
                    // $req->parsedResponseIsFromServer() would return true when though it should not. So we reset it
                    $r->resetParsedResponseIsFromServer();
                }
            }
        } elseif (!is_string($req)) {
            if (!is_bool($resp) && !$req->parsedResponseIsFromServer()) {
                if ($req->id() !== null) {
                    $resp = call_user_func_array(array(static::$responseClass, 'withId'),
                        array($resp, $req->id()));
                }
                if ($this->jsonrpc_version !== null) {
                    $resp->setJsonRpcVersion($this->jsonrpc_version);
                }
                $this->fixErrorCodeIfNeeded($resp);
            }
            $req->resetParsedResponseIsFromServer();
        }

        return $resp;
    }

    /**
     * @param Response $resp
     * @return void
     */
    protected function fixErrorCodeIfNeeded($resp)
    {
        // Jsonrpc 2.0 responses use the same error codes as the phpxmlrpc interop ones.
        // We fix them without changing the global error codes, in case there are some xmlrpc calls being answered, too
        if (($errCode = $resp->faultCode()) != 0 && $resp->getJsonRpcVersion() === PhpJsonRpc::VERSION_2_0) {
            $errKeys = array_flip(PhpXmlRpc::$xmlrpcerr);
            if (isset($errKeys[$errCode]) && isset(Interop::$xmlrpcerr[$errKeys[$errCode]])) {
                /// @todo do not use deprecated property accessor to set this value
                $resp->errno = Interop::$xmlrpcerr[$errKeys[$errCode]];
            }
        }
    }
}
