<?php

namespace PhpXmlRpc\JsonRpc;

use PhpXmlRpc\JsonRpc\Helper\Charset;
use PhpXmlRpc\JsonRpc\Traits\JsonRpcVersionAware;
use PhpXmlRpc\JsonRpc\Traits\SerializerAware;
use PhpXmlRpc\Response as BaseResponse;

class Response extends BaseResponse
{
    use SerializerAware;
    use JsonRpcVersionAware;

    protected $content_type = 'application/json';
    protected $id = null;
    /** @var bool used to tell apart (error) responses generated by the client / request from the ones received from the server */
    protected $is_from_server = false;

    /**
     * @param \PhpXmlRpc\Value|string|mixed $val either a Value object, a php value or the json serialization of a
     *        json-rpc value (a string).
     *        Note that using anything other than a Value object wll have an impact on serialization.
     *        Note that \PhpXmlRpc\Value of type DateTime and Base64 will be serialized as json strings, but not decoded
     *        into the correct type at the receiving end.
     * @param integer $fCode set it to anything but 0 to create an error response. In that case, $val is discarded
     * @param string $fString the error string, in case of an error response
     * @param string $valType The type of $val passed in. Either 'jsonrpcvals', 'phpvals' or 'json'. Leave empty to let
     *                        the code guess the correct type by looking at $val - in which case strings are assumed
     *                        to be serialized json
     * @param mixed $id
     * @param array|null $httpResponse this should be set when the response is being built out of data received from
     *                                 http (i.e. not when programmatically building a Response server-side). Array
     *                                 keys should include, if known: headers, cookies, raw_data, status_code
     */
    public function __construct($val, $fCode = 0, $fString = '', $valType = '', $id = null, $httpResponse = null)
    {
        // accommodate those methods which build a Response using the calling syntax of the PhpXmlRpc\Response class
        if ($httpResponse === null && is_array($id) && isset($id['raw_data'])) {
            $httpResponse = $id;
            $id = null;
        }

        $this->id = $id;

        if ($fCode == 0 && $valType === 'xml') {
            // if the user insists that she's passing in xml, test if it is in fact json
            // (tolerate BOM for UTF-8/16/32 in all its gore)
            if (substr(ltrim(substr($val, 0, 9), "\xEF\xBB\xBF\xFE\xFF\x00"), 0, 5) === '<?xml') {
                $this->getLogger()->error('JSON-RPC: ' . __METHOD__ . ': string value passed in does look like xml rather than json');
            }
        }

        parent::__construct($val, $fCode, $fString, $valType, $httpResponse);

        switch ($this->valtyp) {
            case 'xml':
                $this->valtyp = 'json';
                break;
            case 'xmlrpcvals':
                $this->valtyp = 'jsonrpcvals';
                break;
        }
    }

    /**
     * @return mixed
     */
    public function id()
    {
        return $this->id;
    }

    /**
     * Returns json representation of the response. Sets `payload` and `content_type` properties.
     *
     * @param string $charsetEncoding the charset to be used for serialization. if null, US-ASCII is assumed
     * @return string the json representation of the response
     */
    public function serialize($charsetEncoding = '')
    {
        if ($charsetEncoding != '' && $charsetEncoding != 'UTF-8')
            $this->content_type = 'application/json; charset=' . $charsetEncoding;
        else
            $this->content_type = 'application/json';

        $this->payload = $this->getSerializer()->serializeResponse($this, $charsetEncoding);
        return $this->payload;
    }

    /**
     * Reimplemented to make us use the correct parser type.
     *
     * @return Charset
     */
    public function getCharsetEncoder()
    {
        if (self::$charsetEncoder === null) {
            self::$charsetEncoder = Charset::instance();
        }
        return self::$charsetEncoder;
    }

    /**
     * Reimplemented for completeness.
     *
     * @param string $charsetEncoding
     * @return string
     */
    public function xml_header($charsetEncoding = '')
    {
        return '';
    }

    /**
     * Duplicates a Response, injecting the id
     * @param Response $resp
     * @param mixed $id
     * @return Response
     */
    public static function withId($resp, $id) {
        $version = $resp->getJsonRpcVersion();
        $isFromServer = $resp->isFromServer();
        $resp = new self($resp->value(), $resp->faultCode(), $resp->faultString(), $resp->valueType(), $id, $resp->httpResponse());
        $resp->setJsonRpcVersion($version);
        $resp->setIsFromServer($isFromServer);
        return $resp;
    }

    /**
     * @return bool
     */
    public function isFromServer()
    {
        return $this->is_from_server;
    }

    /**
     * @param bool $value
     * @return void
     */
    public function setIsFromServer($value)
    {
        $this->is_from_server = $value;
    }
}
